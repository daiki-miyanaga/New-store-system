# 設計ドキュメント (改訂版)

## 1. 画面設計 (UI/UX)

-   **ワイヤーフレーム構成:**
    -   **ヘッダー:** 全画面共通。アプリケーション名、ログイン中のユーザー名、ログアウトボタンを配置。
    -   **サイドバー:** 全画面共通。各機能へのナビゲーションリンクを配置。ロール（管理者/店舗担当）に応じて表示項目を制御。
    -   **メインコンテンツ:** 選択された機能に応じて内容が切り替わる領域。

-   **主要画面一覧:**
    -   `LGN-001`: **ログイン画面**
    -   `DASH-001`: **ダッシュボード画面**
    -   `DAIRY-001`: **実績入力画面**
    -   `ORDER-001`: **発注画面**
    -   `SIM-001`: **発注修正シミュレーター画面**
    -   `ANALY-001`: **指定期間調査画面**
    -   `NOTE-001`: **洋生ノート画面**
    -   `MST-PRD/CUS/ETC`: **各種マスタ管理画面** (管理者ロールのみアクセス可)

-   **ユーザー操作フロー (店舗担当者):**
    1.  `ログイン画面`で認証後、`ダッシュボード`にリダイレクトされる。
    2.  `ダッシュボード`でKPIやアラートを確認。
    3.  サイドバーから`実績入力画面`へ移動し、日次実績を入力・保存する。
    4.  `発注画面`へ移動し、推奨発注数を確認。
    5.  必要に応じて`発注修正シミュレーター`で調整し、最終的な発注を確定・送信する。

## 2. アーキテクチャ設計

-   **フロントエンド構成:**
    -   **使用技術:** `HTML`, `Tailwind CSS`, `Alpine.js`, `Chart.js`
    -   **ファイル構成案:**
        ```
        /
        ├── pages/
        │   ├── dashboard.html
        │   ├── daily-report.html
        │   └── ... (各画面)
        ├── components/
        │   ├── layout/
        │   │   ├── header.js
        │   └── ui/
        │       ├── card.js
        │       └── table.js
        └── services/
            └── api.js  // API通信とエラーハンドリングを共通化
        ```
    -   **命名規則:**
        -   **ファイル名:** `kebab-case` (例: `daily-report.html`)
        -   **CSSクラス:** `kebab-case` (Tailwindのユーティリティクラスに従う)

-   **データフロー図（Mermaid記法）:**
    ```mermaid
    sequenceDiagram
        participant User as ユーザー
        participant UI as フロントエンド
        participant API as バックエンドAPI
        participant DB as データベース

        Note over User, DB: 実績入力フロー (サーバーサイド計算)
        User->>UI: 販売数、ロス数を入力し保存
        UI->>API: POST /api/daily-reports (販売数, ロス数)
        API->>DB: 前日在庫を取得
        DB-->>API: 前日在庫を返す
        API->>API: 当日在庫 = 前日残 + 入荷 - 販売 - ロス を計算
        API->>DB: 計算結果を実績テーブルに保存
        DB-->>API: 更新成功
        API-->>UI: 成功レスポンス
        UI-->>User: 「保存しました」と通知
    ```

## 3. データ設計

-   **データベーススキーマ:**
    -   **実績テーブル (daily_reports):** `id`, `report_date`, `product_id`, `sales_quantity`, `loss_quantity`, `ending_inventory`
    -   **商品マスタ (products):** `id`, `name`, `price`, `min_order_quantity`, `order_unit`
    -   **発注テーブル (orders):** `id`, `order_date`, `product_id`, `quantity`, `status`

-   **API仕様:**

    -   **アクセス制御:**
        -   マスタ管理API (`/api/master/*`) の `POST`, `PUT`, `DELETE` は「管理者」ロールのみ実行可能。
        -   上記以外のデータ参照・操作APIは「店舗担当」ロール以上で実行可能。

    -   **エンドポイント:**

        -   **実績入力:** `POST /api/daily-reports`
            -   **バックエンドロジック:**
                1.  リクエストボディを受け取る。
                2.  `product_id` ごとに前日の `ending_inventory` を取得。
                3.  `当日在庫 = 前日残 + 入荷(...) - sales_quantity - loss_quantity` の計算式に基づき `ending_inventory` を算出。
                4.  算出した値で `daily_reports` テーブルに保存。
            -   **Request Body:**
                ```json
                {
                  "report_date": "2025-08-31",
                  "items": [
                    { "product_id": 1, "sales_quantity": 10, "loss_quantity": 1 },
                    ...
                  ]
                }
                ```
            -   **Response (201 Created):** `{ "status": "success" }`

        -   **発注作成:** `POST /api/orders`
            -   **バックエンドロジック:**
                1.  リクエストボディを受け取る。
                2.  `items` の各要素について、`product_id` に紐づく `min_order_quantity` と `order_unit` を `products` マスタから取得。
                3.  `quantity` が `min_order_quantity` 以上であり、かつ `order_unit` の倍数であることを検証。
                4.  検証違反があれば `400 Bad Request` を返す。すべてOKなら `orders` テーブルに保存。
            -   **Request Body:**
                ```json
                {
                  "order_date": "2025-08-31",
                  "items": [
                    { "product_id": 1, "quantity": 20 },
                    ...
                  ]
                }
                ```
            -   **Response (201 Created):** `{ "status": "success" }`

        -   **商品マスタ取得:** `GET /api/products`
            -   **Response (200 OK):** `[ { "id": 1, "name": "商品A", ... }, ... ]`

    -   **共通エラーレスポンス:**
        -   **400 Bad Request (バリデーションエラー):**
            ```json
            {
              "status": "error",
              "message": "Validation failed.",
              "errors": [
                { "field": "items[0].quantity", "code": "ORDER_UNIT_VIOLATION", "message": "発注単位が不正です。" }
              ]
            }
            ```
        -   **401 Unauthorized (認証エラー):** `{ "status": "error", "message": "Authentication required." }`
        -   **403 Forbidden (権限エラー):** `{ "status": "error", "message": "Permission denied." }`

## 4. テストシナリオ

-   **`SIM-001` (発注修正シミュレーター):**
    -   **単体テスト:**
        -   発注数を `order_unit` 分だけ増減させた場合、関連する予測値（予測在庫、予測売上）が正しく再計算されることを確認する。
    -   **結合テスト:**
        -   シミュレーターで変更した値が、発注画面の入力フォームに正しく反映されることを確認する。

-   **`ORDER-001` (発注バリデーション):**
    -   **APIテスト:**
        -   `min_order_quantity` 未満の数量で `POST /api/orders` を実行し、`400` エラーが返ることを確認する。
        -   `order_unit` の倍数でない数量で `POST /api/orders` を実行し、`400` エラーが返ることを確認する。
